<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[go modules 模块解析]]></title>
    <url>%2Fp%2F9c8bdfe5.html</url>
    <content type="text"><![CDATA[原文：Anatomy of Modules in Go摘要Modules 是 Go 语言项目中一个新的管理依赖的方案。Modules 允许我们在项目中可靠的使用同一个依赖的不同版本。在阅读本文之前，请注意 Modules 是从 Go 1.11 开始被支持，并将在 Go 1.13 的版本中被真正完善。所以当在使用 Go 1.13 以下的版本时，其实现可能会在未来有所调整。（译者：当前稳定版为 Go 1.12.5, Go 1.13 预计应当在 2019 年 8 月左右会发布）历史问题强制使用 GOPATH回顾下在没有 Go Modules 的时候的大家的工作环境。当我们有需求去编写 Go 语言的代码时，需要将代码放置于$GOPATH的路径下（这就是我们的 Go workspace 工作区）。当我们使用命令go get去安装依赖包(译者：以下所有包都对应着 go 的 package 概念，不再单独指出，而项目需要使用的非本项目的 package 则称为依赖包)的时候，依赖包的代码将会被存入$GOPATH目录下。只有当依赖包的代码被存入$GOPATH 后，我们编写的代码才能够成功地引用它。同时当我们使用go build命令创建代码相应的二进制文件时，也将会存储在$GOPATH内。所以说，这个时期的$GOPATH是 Go 中非常重要的一个概念。而很多情况下用户还是无法接受这种强制要求将所有项目放在固定目录的设定。无法使用同一依赖包的多个版本由于go get会将依赖包不同版本的代码放入同一个目录（因为目录名称就是依赖包的包名）所以我们也无法在项目中使用同一个依赖包的不同版本。如果我们真的需要在 GOPATH 之外进行开发，那么我们需要相应的修改GOPATH的环境变量，当我们改动了GOPATH后，之前所安装的依赖包也需要从原本的GOPATH中将代码拷贝过来或者重新使用go get进行安装。没有中心化的包管理源有一个有趣的事实，Go 语言并没有提供软件中心给用户下载依赖包，如果你是 node.js 的开发者，你会很熟悉 npm 仓库，它给用户提供了下载和发布 node.js 模块的功能，而这样的功能在 Go 中又是如何完成的呢？通常，引用一个第三方的 Go 依赖包需要在代码中写上如下的声明:1import "github.com/username/packagename"如果仔细关注这段代码，你会发现依赖包的名称看起来很像 URL，不好意思，它就是 URL。Go 可以下载和安装互联网上任何网站的 Go 包，如果你想安装上述的依赖包，你可以用如下的go get命令：1go get github.com/username/packagename如果https://github.com/username/packagename这个 URL 可以被正确的解析，Go 就会访问它并下载包的代码。当下载完成后，其中的文件会被存放于$GOPATH/src/github.com/username/packagename的路径下。注意，Go 标准库包的代码则是放在$GOROOT目录下（当 Go 环境安装完成时就已经存放在此）。而我们普通用户的各个包的代码都会储存在$GOPATH内。对比 npm，npm 会将依赖包存放在本项目的目录下（项目下的 node_modules 目录），并不像$GOPATH那样存在统一的位置（但也不能像$GOPATH那样可以被重新设置）。在 npm 中，我们有package.json文件（同package-lock.json文件一起）将当前项目所安装的依赖包及版本精确的以文本形式记录下来。go get工作流程接下来让我们来理解下go get是如何工作，而我们需要如何维护自己的 Go 包。首先像上面安装包那样运行下面的指令：1go get domain.com/path/to/sub/directory此时 Go 会先尝试以安全的HTTPS协议来访问网站domain.com/path/to/sub/directory。如果这个 URL 不支持HTTPS或者返回 SSL 错误，同时GIT_ALLOW_PROTOCOL 环境变量中包含HTTP协议，那么 GO 就会退而求其次的尝试用HTTP协议来解析这个 URL。网络上的 Go 包应当是使用像GIT或者SVN这样的（VCS）进行版本管理的代码仓库，以下这些版本管理系统（VCS）是被支持的：12345- Bazaar .bzr- Fossil .fossil- Git .git- Mercurial .hg- Subversion .svn如果 domain.com 是一家 Go 支持的知名代码托管网站，那么 Go 会先尝试解析domain.com/path/to/sub/directory.{type}，其中 type 可以是git hg 等指定类型。下面是 Go 支持的代码托管网站及相应的 type 类型。1234- Bitbucket (bitbucket.org) .git/.hg- GitHub (github.com) .git- Launchpad (launchpad.net) .bzr- IBM DevOps Services (hub.jazz.net) .git当一个版本管理系统支持多种协议时，Go 会依次尝试使用每种协议来解析 URL。比如 Git 就支持 https 协议和 git+ssh 协议，这些协议会被 Go 依次尝试。如果 Go 成功的解析了上面的 URL，就会使用相应的工具（如 git）进行克隆并存储于之前我们分析的$GOPATH/src下的对应目录。但是如果该包的 URL 并不是 Go 支持的代码托管网站，Go 就没有办法立刻确定对应的版本管理系统。这种情况下 Go 会试着用上面我们说的支持的版本管理系统来解析 URL，如果 URL 被成功解析并返回HTML 文档，Go 会查找文档内如下的特殊meta tag：1&lt;meta name="go-import" content="import-prefix type repo-root" /&gt;注意：为了避免出现解析错误，这条meta tag应当尽可能放在 HTML 文件的开始部分让我们简单解析下这条 meta tagimport-prefix: 这是包被 import 时的路径，在我们的例子里它应该是 domain.com/path/to/sub/directorytype: This is the type of your VCS repository. It can be one of the supported types mentioned earlier. In our case, it could be a Git repository, hence git type.type: 这是该包对应的版本管理系统（VCS）类型，它应当是我们之前提到的受 Go 支持的类型之一。在我们的例子里它应该是 gitrepo-root: 这是版本管理系统下该包的代码仓库的 URL，例如在我们的例子里，它可以是 https://domain.com/repos/name.git 这个 git 后缀是可选的，因为我们在之前的 type 中已经提到了它是 git 类型使用这个 meta 信息，Go 就能够在 https://domain.com/repos/name.git里使用 git 命令行工具克隆仓库并把代码存入$GOPATH/src/domain/path/to/sub/directory目录下了。如果import-prefix的值不同于go get命令里的 URL，Go 会选择将代码放入import-prefix对应的目录。例如使用下面这条go get命令：1go get domain.com/some/sub/directoryGo 会访问https://domain.com/some/sub/directory, 如果站点返回的 HTML 文档内容中是以下的 meta tag：1234&lt;meta name="go-import" content="domain.com/someother/sub/directory git https://domain.com/repos/name.git"/&gt;由于import-prefix 与go get命令里的 URL 不同，Go 会验证是否domain.com/someother/sub/directory也返回同样的 meta tag，然后包会被安装在$GOPATH/src/domain.com/someother/sub/directory目录下，依赖该包的 Go 文件需要添加如下声明语句：1import "domain.com/someother/sub/directory"向后不兼容难题目前为止，我们已经对 Go 以往进行包管理的方案有了足够的了解，让我们看看这样的方案在包不向后兼容时会产生怎样的问题。假定位于github.com/thatisuday/stringmanip是一个支持 string 字符串处理的包（比如将 string 中的字符转成大写之类）。当用户使用go get进行下载时，会克隆该包代码仓库 master 分支的最新 commit 提交版本。这时突然一个新的 commit 提交改变了某个函数的实现，加入了一些与之前代码不兼容的修改，或是创建了一些 bug。此时当用户更新或者重新安装该包，依赖该包的代码就会由于这些变动而导致无法运行。我们没有办法使用go get指定克隆 git 仓库的特定 commit 或者是 tag。这也表示我们无法下载包的指定版本。同时由于 Go 将包下载到以其包名命名的目录，我们也无法同时存储一个包的多个版本。这是种非常粗暴的包关系处理方案，而现在Go Modules将来解决这个问题。Go Modules 教程设计要求让我们首先理解下Go Modules的原理。对比我们讨论过的 Go 原本的包管理方案，很容易想到下面几点改进：首先，我们应当可以在任何目录下工作，而不是仅仅在$GOPATH下。这可以让我们灵活的按个人需求放置源代码。其次，我们应当可以安装某个依赖包的历史版本，以保证可以避免遭遇更新而导致的不向后兼容的问题。然后，我们应当可以引用一个依赖包的多个版本。这在我们的旧应用代码还在依赖着旧版依赖包持续运行，而我们想使用新版依赖包进行一些新的开发时非常有用。最后，类似 npm 的package.json，我们需要在项目里有一个文件来记录这些依赖包。当我们在分发项目时，我们就不需要同时把这些依赖包的代码一起发送出去，Go 可以对照这个文件然后帮我们下载所需要的依赖包。好消息是，Go Modules能够实现我们上面的所有要求，并且做的更好。Go Modules给我们提供了原生的依赖管理系统。让我们来理解这个新概念“模块（module）”的定义，一个模块是指一个包含 Go 包的目录，它可以是分发包（distribution package）也可以是可执行包（executable package）。(译者：个人认为想表达的是模块既可以是一个可以直接产生二进制文件执行的包，也可以是提供给其他包各类工具函数作为依赖的包)一个模块也可以像包一样与别人共享。因此，它必须使用 Git 或者其他 VCS 版本管理系统进行管理，例如托管在 Github 这样的平台，Go 推荐：一个 Go 模块必须是一个代码仓库，或者某个代码仓库中包含一个独立的 Go 模块一个 Go 模块应当包含一个到多个包一个包应当在单独的目录下包含一到多个.go文件创建 Go Module 模块看完了理论，让我们用代码尝试一些操作。首先创建一个空目录，不要放在$GOPATH下。我现在使用nummanip目录来存放我的 Go 模块，这个目录下将存放一些包以及处理number这个数据结构。正如我们之前提到的Go Modules需要一个代码仓库，我们在 Github 上使用以下这个URL创建一个 Git 代码仓库。接下来我们需要在该目录初始化Go Modules。使用go mod init命令来创建go.mod文件（类似 npm 的package.json文件），文件中会包含模块对应的引用路径和模块会使用的依赖包。我们也要初始化 Git 代码仓库，将目录与远端的 Github 仓库建立联系。1234mkdir nummanip &amp;&amp; cd nummanipgit initgit remote add origin https://github.com/thatisuday/nummanip.gitgo mod init github.com/thatisuday/nummanip注： 默认情况下在$GOPATH内创建模块是被禁止的，会返回go: modules disabled inside GOPATH/src by GO111MODULE=auto; see &#39;go help modules&#39;的错误。这也是在为后期废弃$GOPATH做的预防措施。如果真的有这方面的需求，可以将GO111MODULE这个环境变量设为on。创建的go.mod文件包含模块引用路径和模块创建时 Go 的版本（译者：当前都为 Go 1.12，在 Go1.11 早期版本时go init命令不会写入 go 的版本信息）。前面这些复杂的准备工作完成后，我们就能开始我们编写模块内各个包的代码了。我们在模块内创建了两个包。现在它们还是空的目录，接下来我们放入一些代码。calc包将提供 number 之间的计算方法，而transform包则提供 numer 相关的数据结构类型转换的功能。当我们在模块中编写多个包的时候，我们需要给它们每个都创建一个文件夹。但如果只想提供一个单独的包，我们就不需要在当前文件夹下再新建一级，直接将包的代码文件放在模块路径（go.mod文件所在的路径）下。仅在我们引用这些包时会有些区别，我们稍后会谈到这些。创建本地模块到了这一步，我们并没完全决定我们的模块是一个可执行应用还是给大家提供各种工具的 library 库。我非常推荐大家将自己代码中可重复利用的逻辑抽象成独立的包并且在应用中引用它们。所以为了测试我们的模块和包，我们再创建另一个模块来使用nummanip模块，这个用来测试的模块我并不想不发布到网络上，此时我们可以使用一个非 URL的模块名来初始化它。Go 提供了go test工具帮助我们使用第三方测试组件来测试我们的代码，这和我们接下来的教程并不是同一个话题。我们为了测试使用go mod init main命令创建了main模块。为了方便，我们在 VSCode 工作区里同时打开了main和nummanip两个模块的目录。我们在calc包里编写了math.go文件来提供Add工具函数用于返回两个数字之和。注意包的申明部分，package calc标识了math.go这个文件属于calc包，而由于本包是在模块内独立的文件夹calc中的，所以这段包名称的申明与模块名称是没有关系的。如果我们的包代码直接是放于模块目录下，那包名就应当和模块的名称相同（为了保证在import引用时可以正确的解析)提交模块的首个版本接下来让我们尝试发布模块。发布模块其实就是简单的将代码推向远端仓库的指定 tag 分支。在我们做之前，先理解两个概念语义化版本号和git tags。语义化版本号语义化版本号（Semantic Versioning 或 SemVer）是一个被广泛接受的标记发布的模块或者包的方案。它通常用 vX.Y.Z的格式表示，其中X表示主要（major）版本，Y表示次要（minor）版本，Z表示补丁（patch）版本。例如一个包的版本是1.2.0，就表示它主要版本是 1，次要版本是 2，补丁版本是 0,。我们会在包仅有小修改时增加补丁版本，当新功能或者性能提升时增加次要版本，当与旧版本之间产生很大的变更时，我们提升主要版本。提升主要版本时，次要版本和补丁版本都重置为 0（比如2.0.0）额外的预发布版本可以通过增加后缀的方式表达，例如x.y.z-rc.0表示一个预发布序号为 0 的版本（或者x.y.z-beta.1）。这对一些需要测试预发布版本的软件很有帮助。Go 指定了，当新旧版本之间不兼容时，新版本应当进行主要版本号的更新。当新的主要版本(例如 V2.0.0)发布时，Go 会将其当做一个不同的模块来对待，这点很重要，后面我们会演示。我们知道，Git 的分支其实就是一系列提交历史的集合。每个提交有自己唯一的识别码（commit hash）。在某个特定的提交版本我们可以知道仓库中文件的状态。当发布代码时，我们需要同时提供当前的 commit hash 来保证用户在他们的生产环境使用这些代码时，代码是处于此 commit hash 状态稳定不会变动的。另一种方法就是给这个 commit hash 起一个别名，例如 SemVer 语义化版本号，这种方案可以称为打标签taggingGit 提供了两种打标签的方法，Lightweight Tag这种是简单的指向 Git 历史中的一次提交。而Annotated Tag则是保持了 Git 自身数据库中的所有对象（包括一些额外信息，如打标签的用户姓名，标签信息和其他等等）。关于Annotated Tag你可以阅读这里的详细资料，我们将使用Lightweight tag的方式打标签。这是我们第一次发布此模块，我们需要创建一个提交并将其推送到远端。然后我们对刚刚的提交使用语义化版本号的形式打上标签。上图就是完成提交和推送的过程（译者：如读者跟随教程一起实验，请在 push 前执行git add . 和git commit -m&quot;xxx&quot;操作），-f参数强制推送这在第一次提交时是没问题的，接下来打标签。我们首次发布版本，可以用v1.0.0的语义化版本号。当我们发布Go Modules模块的时候，我们的语义化版本号标签名必须是以小写的v开头。在创建完 git 标签后，我们需要使用git push --tags命令推送到远端仓库。接下来我们在main模块内创建app.go文件来测试是否版本发布生效。我们从github.com/thatisuday/nummanip模块中引用calc包，并调用它的Add方法。由于我们既知道模块路径又知道包名，我们可以直接 import 引用包的完整 URL 路径。如果我们的包代码是直接写在模块目录下的，我们可以只 import 引用github.com/thatisuday/nummanip并使用nummanip作为包名去执行nummanip.Add()函数注意，到现在为止我们还并没有使用go get命令来安装这个模块。确实我们可以通过go get来安装它。但其实当我们尝试使用go run &lt;file&gt;来运行app.go文件时，Go 会分析引用并自动请求最新版本v1.x.x（稍后再解释这点）的nummanip模块。当 Go 成功下载模块后，它会同时将下载的依赖模块信息更新记录到go.mod文件中。这种方案能够帮助我们不需要告诉其他人需要安装什么什么依赖，Go 可以直接通过解析go.mod文件来处理模块所需的依赖。(译者：图中 nummanip 版本为 v1.0.1 应该为 v1.0.0，此图可能是作者后期补充，版本号由于后面的操作而被修改过)你可能会疑惑，Go 是如何解析 import 引用的 URL 的。例如https://github.com/thatisuday/nummanip/calc是会返回404 Not Found页面。关于这点，我也没能查到详细的文档，但是我猜测由于 Github 是 Go 可以识别的代码托管网站，Go 对其是有特殊的方案来定位包的位置，就像这里所说的。现在可能我们还有一些不解。Go 什么时候会自动安装依赖模块？go get还有什么用处？这些模块代码被储存到哪里去了？Go Modules被存入$GOPATH/pkg/mod目录下（module 缓存路径）。看起来我们好像还是没有摆脱$GOPATH的魔掌。但是 Go 确实需要找个公共的目录以保证不会将同一个包的同一个版本重复下载。而当我们执行go run命令或者go test; go build这样的 Go 命令时，Go 会自动的检查第三方 import 引用申明（类似我们这个模块里的引用），并且将依赖模块的代码仓库克隆到本地 module 缓存路径。我们可以看到模块缓存路径中有nummanip模块，且是标记为v1.0.0版本时的代码。Go 同时创建了go.sum文件来保存直接或间接被本模块引用的依赖模块的内容的 checksums（类似 commit hash，用来检测文件内容是否更改，一旦更改此计算值也会变化）。npm 的package-lock.json文件是一个锁定文件，为了 100%重现编译过程而存储引用的依赖版本信息，而go.sum文件并不是用于锁定版本的文件，它应当和我们的代码一起提交到代码仓库中（详细解释）。不过当其他人使用此模块时go.sum通过记录每个模块的 checksums 也能给 100%重现编译环境有很重要的帮助。（译者：这段主要看下详细解释，我并没有完全理解两个文件之间的区别，感觉是说 go.sum 并不强制而 package-lock.json 是强制的）升级 patch 补丁版本号并使用接下来让我们添加些代码，为模块生成一个新的补丁版本。当我们修改Add函数的参数形式，通过可变参数的方案使其能够接受多个参数时，我们推送了一个新的标签v1.0.1。让我们在main模块中使用新的Add函数。由于 Go 之前已经下载了nummanip模块，所以go run命令不会主动获取新版本的依赖模块。为了使用新版，我们需要手动更新我们的依赖模块（在最坏的情况下可能会需要重新安装）为了更新当前已经存在于go.mod文件中的依赖模块，我们需要使用go get -u的命令。这条命令会更新所有的模块，将它们的次要版本或补丁版本提升到最新，但不会改变主要版本（后面将解释）。如果当新的次要版本出现后我们也只想更新 patch 补丁版本的话，可以使用go get -u=patch命令来实现。如果需要使用某个依赖模块的某个精确的版本，我们需要使用go get module@version命令。例如在我们的例子里为了安装v1.0.1版本，我们应当使用go get github.com/thatisuday/nummanip/calc@v1.0.1命令来实现。（译者：原文用 1.1.2，感觉 1.0.1 更合适且读者可以立刻尝试此命令）正如你所看见的，使用go get -u后 Go 下载了最新v1.0.1版本的模块并储存到缓存目录中。这样在公共基本的依赖管理方案就可以让系统里各种模块同时使用依赖模块不同的版本。升级 Major 主要版本号并使用现在是时候解释为什么使用go get -u命令升级依赖模块的版本时，Go 仅仅会处理v1.x.x这样的版本号了。大家通常会有这样的共识，当某个软件有了相对很多的更新和修改后是需要升级软件的 major 主版本号的。例如Angular v1和Angular v2就有很多不同。同理，当某个依赖模块以特定的 major 主版本号的状态被 import 引用时，如果升级到新的 major 主版本号就可能会导致不兼容，让我们的一些代码无法正常工作。那如果我们的应用可以在 major 大版本升级后正常的编译和运行的情况下，go get -u会升级 major 大版本号么，像v1.0.2到v2.0.0这样。Go 怎么处理这种需求呢？在 Go 的理解里，当我们更新依赖模块到新的 major 大版本时，它认为从技术上说由于不保证向后兼容性它们是不同的模块。所以v1.x.x和v2.x.x是两个模块，这意味着用户必须手动使用go get安装那些已经 import 的模块的新版本，并且给新版本一个新的指定的 import 引用路径。那么这个新的 import 引用路径是什么样的呢？由于我们在go.mod文件中已经存在了之前我们引用的旧版本依赖模块的 URL 名称，我们需要修改一些东西来区分新旧版本。其实只需要简单的将 major 主版本号以（vX）的形式接到原本 import 引用路径后面，这样用户就能同时使用一个依赖模块的多个版本了。让我们实际操作下：上图可以看到，我们修改了Add函数的实现来检查是否传入至少两个参数，并在不符合的条件下返回 error 错误作为第一个返回值，而正常情况下则会返回无错误以及实际的数字之和作为第二个返回值。现在这个Add函数的实现和原本的v1.x.x版本仅返回一个数值的实现差别很大，旧代码需要修改。这意味着我们的代码不能向后兼容。所以下一个发布版本理应变更为v2.0.0，以保证 Go 能正确的认为这是不同的模块，而不会让过去的代码自动升级到这个版本。如果你注意到，我们为新的 major 主版本创建了新的 branch 分支v2。这会在我们需要继续维护v1版本去处理 bug 和优化代码的时候轻松一些。现在我们要更新go.mod文件，在模块申明的部分加入版本号的后缀。（译者：原文为 prefix，我觉得实际应该是想表达 suffix）虽然这里 import 引用路径有点让人迷惑，但是 Go 还是能够理解vX标记的含义，并正确的解析模块引用。vX是固定的，需要精确的对应 SemVer 语义化版本号的 major 主版本，例如v2就是对应v2.x.x的发布版本号。在上面的例子中，我们安装了nummanip模块的新 major 主版本。由于这是 major 主版本的更新，需要手动的使用go get在项目中安装。而新的模块也需要使用新的标记来 import 引用。需要给我们新版本模块里的包名另起一个别名是比较麻烦的事情。由于我们 import 引用了同一个包的两个不同版本，我们需要对其中一个 alias 起一个别名来解决包名变量重复的冲突。在这里，我们对v2/calc包起了calcNew的别名，并使用calcNew.Add来调用新版函数。你可以看到，go get命令写入了新版本的模块信息到go.mod文件中，并将新版本的模块下载到了模块缓存路径里。编译运行可执行的模块当我们编写一个可执行的模块时，可以使用go run &lt;filename&gt;或者是go run path/*.go来运行模块。当编译时，可以使用go build命令编译模块，其二进制输出会生成在当前的目录下，或者使用go install命令会将模块的二进制输出放到$GOPATH/bin目录下。对于非可执行的模块，如我们例子中的nummanip模块，不像Go1.11 之前的行为，我们无法使用go install命令来生成 package archives。这是由于go install命令无法从 Git 的历史提交或 Git 的标签信息中预测模块的版本号（SemVer 语义化版本）。同样的 Go Modules 也不能将包存成 binary archives 的形式，像窝在packages 教程中表述的那样。间接依赖模块（Indirect Dependencies）上文中我们使用了间接依赖模块这个名称，但并没有解释它。顾名思义，其实间接依赖模块就是在我们的模块中没有直接使用到的模块。直接依赖的模块是我们在代码中声明使用到的模块，而间接依赖模块，则是被直接依赖模块所依赖的模块。go.mod文件会记录下直接和间接依赖模块，并使用//indirect来标识间接使用模块，如下图：在上图中，我们知道github.com/fatih/color是一个直接依赖模块，因为我们在代码中 import 引用了它。当我们运行或编译该模块时，Go 会更新go.mod文件并且添加indirect注释到非直接引用的模块后面。我希望上面的这些关于 Go Modules 的介绍足够清楚了，但是还是有一个问题：当我们没有在模块引用申明中写出版本后缀（在go.mod文件的依赖模块部分）时，Go 会自动使用哪一个版本的模块？答案是最新的v1.x.x版本，因为在默认情况下 Go 认为版本后缀是v1。最小版本选择（MVS）说到了现在，我们可以 import 引用同一个依赖模块的不同版本，不过需要他们的 major 大版本号不同。当两个版本仅在 minor 次要版本和 patch 补丁版本号上有不同时我们却没有办法同时使用多个版本（因为在写 import 引用申明时，这些 minor 和 patch 版本号不同的模块并没有区别）。如上图，我们有一个模块依赖了模块 A和模块 B。这两个模块都同事依赖了同样的模块模块 1。但是问题出现了，模块 A依赖的是v1.0.1版本的模块 1，而模块 B依赖的是v1.0.2版本的模块 1。每个模块都定义了minimal version最小依赖版本以保证它们自身可以正常工作。所以如果我们使用v1.0.1版本的模块 1用于最后的编译，那么模块 B可能运行会有异常或者直接就无法进行编译。因此在编译中，我们只能用使用此依赖的一个版本，这是一个Diamond Dependency Problem 钻石依赖问题，如下图所示：正如 Go 所推荐的，同一个模块的多个版本，如果使用的是一个主版本号时，它应该是是能够向后兼容的。这样，当我们在使用v1.0.2版本用于编译运行时，它会能够包含v1.0.1版本的所有能力。Go 将这称为Minimal Version Selection 最小版本选择(其实也意味着在所有最小依赖版本号中选择最大的那个)。MVS 的详细解释在这篇文章中。所以最后我们应当选择v1.0.2版本的模块 1。结语Go Modules现在仍然还在 beta 测试阶段，未来可能会有一些新的变动。由于我不能时刻了解这些信息，所以如果有新的变化出现，请随时与我联系。非常感谢。附赠的小 Tips 提示如果你现在想发布一个模块，但是它的go.mod文件还没有记录下模块源码中的依赖模块信息，你可以使用go build ./...命令来处理这个问题。其中./...的形式会匹配此模块下所有的包并且下载其中还没有下载的依赖模块。这样就可以保证在发布模块之前所有使用到的依赖都被go.mod文件所记录下来了。如果认为go.mod文件中记录的一些依赖是当前项目中不再使用的，可以使用go mod tidy命令来自动清理这些未使用的依赖模块。有时在跑一些自动化测试时，有一定几率我们的测试机会遇到网络问题而导致无法下载依赖模块。此时我们需要预先提供依赖。这个被称为vendoring，可以尝试使用go mod vendor命令去将所有的依赖下载到vendor文件夹下（在go.mod所在的目录），当使用go build命令时，你可以使用go build -mod vendor命令强制指定让 Go 使用vendor目录下的依赖进行编译，而不是默认的模块缓存路径$GOPATH/pkg/mod。go mod graph命令会展示模块依赖关系图GopherCon 2018 中的演讲可以简明的让你理解Go Dependency Management with versioning官方的Go Modules文档链接]]></content>
      <categories>
        <category>Golang</category>
        <category>Modules</category>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派安装ubuntu18.04的aarch64架构版本]]></title>
    <url>%2Fp%2F8c1bf925.html</url>
    <content type="text"><![CDATA[最近收拾东西，发现了桌子上落灰的树莓派，思考了下，准备把它拿来做项目的测试系统之一把官方的系统raspbian下载下来并用Win32 Disk Imager烧到 tf 卡中，启动并配置完成，运行 go 命令的时候发现了问题，这官方的 raspbian 系统是 32 位的系统，需要使用go1.x.linux-armv6l.tar.gz这类名字的二进制，而不能用go1.x.linux-arm64.tar.gz，安装完成 go 后对项目进行 test，发现了其无法对 cgo 的部分代码完成支持，提示我类型不支持，address space 不够，看起来就是 32 位系统无法很好的支持 c 中一部分 64 位寻址的操作而导致的问题所以我就走上了寻找 64 位支持树莓派系统的道路。支持树莓派 64 位的镜像其实这个镜像并不难找，搜索一下就能看到一些基于 Debian 9 的pi64基于 Ubuntu18.04 的ubuntu64-rpi其中Ubuntu64-rpi是国人的项目(看 Github 描述还是个高中生= =，19 年接下来要高考，祝他高考顺利！)，其中也提供了预编译完成的镜像进行下载，start 数量也很多，所以我就选它了。安装 Ubuntu64-rpi首先下载镜像及安装工具，github 的文档中给出了详细的介绍。我这里使用的是 windows 系统进行下载安装的，操作主要就是：去百度网盘下载镜像压缩包cxcore-ubuntu-18.04-arm64+raspi3-final.img.xz，提取密码18cy然后用 7zip 解压 xz 文件随后使用Win32 Disk Imager烧录到 tf 卡中把 tf 卡放入树莓派，接入电源，等待启动（首次启动会自动扩容）然后重启后进入命令行界面（此镜像不带图形界面，需要自己 apt 安装），注意连接有线网络进行安装，在安装过程中有一步在检查网络连通性，不连接网络的话会读秒很久使用用户名ubuntu，密码ubuntu就可以登录啦！最后uname -a 可以看到架构和版本信息后续配置现在我们拥有了一个 aarch64 版本的 Ubuntu18.04 系统，时区、Ubuntu 软件源也都设置成国内的状态（+8:00, 清华软件源）也可以跟随教程配上树莓派的软件源(PS: 有一定风险)由于我使用了 rocksdb 做存储，需要编译 aarch64 版本的 rocksdb 依赖，编译时发现内存不够，机器会卡死，原来是默认配置中没有添加 swap（swap 对于低内存机器的稳定运行有着很好的帮助）添加 swap 文件并开机自动生效我们这里增加了/var/swapfile 这个文件，并将这个文件作为 swap 分区1234sudo dd if=/dev/zero of=/var/swapfile bs=1M count=2048 # 写入1MB * 2048 = 2G大小的0到/var/swapfile文件中sudo chmod 600 /var/swapfile # 修改该文件权限为600，为了后续步骤不提示权限警告sudo mkswap /var/swapfile # 把该文件改为swap的格式sudo swapon /var/swapfile # 把该文件配置为swap这时你就可以free -m 观察 swap 分区的大小其中 2047 就表示了约 2G(2048M)的 swap 总量注意此时仅是临时生效，若想要重启后也生效，需要在/etc/fstab 文件中加入以下一行sudo vi /etc/fstab1/var/swapfile none swap sw 0 0保存文件后重启依然可以维持 2G 的 swap 空间安装 golang现在的系统是 aarch64 即 arm64 位的系统，可以使用类似 go1.12.linux-arm64.tar.gz 格式的二进制分发格式进行下载安装。1234567cd ~ # cd到home目录中wget https://dl.google.com/go/go1.12.linux-arm64.tar.gz # 下载go1.12的arm64二进制压缩包tar zxf go1.12.linux-arm64.tar.gz # 别使用zxvf，显示解压的内容对树莓派来说压力太大，超卡的= =mv ~/go ~/golang # 为了和默认的GOPATH分开，防止后面使用go命令下载的内容和源码混在一起echo &quot;export PATH=$HOME/golang/bin:$PATH&quot; &gt;&gt; ~/.bashrc # 将golang的bin目录添加到 PATH环境变量中source ~/.bashrc # 加载刚才设置的PATH环境变量go env # 检验go指令是否成功安装安装完成后，我在项目中运行 go test 完美通过～ 开心！最后和你的树莓派好好玩耍吧]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>树莓派</tag>
        <tag>arm64</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用docker配置安装SFTP服务]]></title>
    <url>%2Fp%2F7245841c.html</url>
    <content type="text"><![CDATA[这个想法的起因是我需要给同事们共享 8 个 G 的会议视频，而我在公司里的 OwnCloud 账户容量不够，运维同学说运行 OwnCloud 的服务器磁盘不够了，也没配 LVM，不好增加容量。原本准备用传统的 FTP 来上传和分享，但转头在使用 OwnCloud 的时候发现它可以配置外部存储，支持 SFTP 但不支持 FTP，所以就开始配置这个 SFTP 的流程了。安装 docker 环境和设置国内源这部分材料比较多，可以参见我的ubuntu 17.04 下安装 docker 国内镜像教程，我就不在这里说了，反正就是需要一个方便可用的 docker 环境，国外源下载很慢，配置下国内源以节约时间。使用镜像文件启动基于 Docker 的 SFTP 服务SFTP 服务我简单搜索了下，简单的解释就是 FTP 的安全版本，是基于 SSH 登录服务的文件传输服务，常用的 openssh 软件包都内置了这项功能。但正是因为它和 SSH 服务绑定了，所以配置起来总感觉影响太广，也不方便进行用户的增删，所以配置一个 docker 来隔离这项功能是比较舒服的方案。编写配置文件这里我们使用了atmoz/sftp这个 dockerfile，在启动前我们要在文件夹下创建这样几个文件/文件夹users.conf 文件这个文件定义了可以登录的用户信息，包括用户名和密码，后面的用户 id 保证不重复，groupid 任意填写（推荐全部相同即可）1vim users.conf单行格式： username:password:userid:groupid12345foo:123:1001:100bar:abc:1002:100baz:xyz:1003:100bazz:xyz:1004:100bay:xyz:1005:100share 文件夹1mkdir share该文件夹下的文件将会映射到所有用户的根目录下，并且是只读权限，用户可以下载其中的文件sftp.d/init.sh 文件sftp.d 文件夹将映射到 docker 中的启动目录，这样在创建 docker 的时候会运行该目录下的脚本。而下面这个 init 脚本的作用是挂载上述 share 文件夹，并且在用户目录下建立可读写的 upload 文件夹编写 init.sh12mkdir sftp.dvim sftp.d/init.sh文件内容如下123456789101112131415161718192021#!/bin/bashfunction bindmount() &#123; if [ -d "$1" ]; then mkdir -p "$2" fi mount --bind $3 "$1" "$2"&#125;for user_home in /home/* ; do if [ -d "$user_home" ]; then username=`basename $user_home` echo "Setup $user_home/upload folder for $username upload files" mkdir -p $user_home/upload chown -R $username:users $user_home/upload echo "Setup $user_home/share folder for all user" bindmount /share/ $user_home/share fidone在创建完成后需要给 sftp.d/init.sh 增加执行权限1sudo chmod a+x sftp.d/init.sh编写启动脚本1vim run.sh内容如下：1234567891011121314#!/bin/bash# after change users.conf, you should rerun this scriptdocker stop sftpd | grep -v "No such container: sftpd"docker rm sftpd | grep -v "No such container: sftpd"docker run \ -v `pwd`/users.conf:/etc/sftp/users.conf:ro \ -v `pwd`/ftpdata:/home \ -v `pwd`/share:/share \ -v `pwd`/sftp.d:/etc/sftp.d \ --cap-add=SYS_ADMIN \ -p 2222:22 \ --name sftpd \ --restart=always \ -d atmoz/sftp在创建完成后需要给 run.sh 增加执行权限，然后运行脚本12sudo chmod a+x run.sh./run.sh运行完脚本后会在当前目录新建 ftpdata 目录，该目录是用于存放用户文件，每个用户会在该目录下有个同名文件夹。保存备份数据也只需要复制该文件夹即可。当在对 users.conf 文件做修改后（如添加删除用户，更换密码），需要再次执行 run.sh 脚本以生效。编写停止脚本 stop.sh12#!/bin/bashdocker stop sftpd | grep -v "No such container: sftpd"同样该脚本需要添加执行权限，在需要关闭 SFTP 服务时执行该脚本。使用 SFTP 客户端进行检验我这里常用的 FileZilla 客户端配置如下图同时，让运维同学开启了 OwnCloud 的 SFTP 外部存储服务，个人配置如下图最终一个运行中的服务目录结构如下图：每个用户可以在自己的 upload 文件夹下进行上传文件，而 share 文件夹内的内容所有用户都能下载（我在这放了一个 Readme 让所有用户可以看到简单的使用方法），但不能上传。这样我就可以使用 OwnCloud 里的分享等功能来进行视频的分享，同时也不需要运维同学担心磁盘的问题了（让他在另一台机器上部署了这个 SFTP 的 docker 服务）]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>sftp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拷贝个人命令行相关配置到服务器中]]></title>
    <url>%2Fp%2F5e938be9.html</url>
    <content type="text"><![CDATA[如何快速的将我本地运行的环境转移到一台新安装的服务器环境呢？可以省略一些代码补全插件，但是常用的一些显示优化，操作简化的插件还是需要可使用打包并上传本地安装文件夹由于我的仓库 dotfiles 中不只包含了 vim，还有 zsh、tmux 等设置，我将其一并打包和安装。tar -zcvf dot.tar.gz dotfiles， 而后scp dot.tar.gz username@server_ip:/path/to/receive解压并安装依赖123456789101112131415161718192021222324252627282930sudo yum -y install epel-releasesudo yum install -y zsh gcc python34 ncurses-devel wget unzip lua-devel python-devel perl-devel ruby-devel python34-pip python34-devel cscope words tmux gittar zxvf dot.tar.gzcd dotfiles/cd zsh &amp;&amp; zsh Install.sh &amp;&amp; cd ..cd vim &amp;&amp; zsh Install.sh &amp;&amp; cd ..cd python &amp;&amp; zsh Install.sh &amp;&amp; cd ..cd ..wget https://github.com/vim/vim/archive/master.zipunzip master.zipcd vim-master/src./configure \ --enable-gnome-check \ --enable-gtk2-check \ --enable-multibyte \ --enable-python3interp \ --enable-rubyinterp \ --with-compiledby="Terry Ding &lt;terryding77@gmail.com&gt;" \ --with-python3-config-dir=/usr/lib64/python3.4/config-3.4m \ --enable-cscope \ --enable-gui=auto \ --with-features=huge \ --with-x \ --enable-fontset \ --enable-largefile \ --disable-netbeans \ --enable-fail-if-missingmake &amp;&amp; sudo make installcd ../..sudo pip3 install neovim至此 算是基本可以开始使用该 vim+zsh 的环境了有些细节问题可以通过去除部分插件进行修正，如删除 zshrc 中的 nvm 插件可以不用在初次进入 zsh 中等待下载 nvm]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用gitlab的pages功能让百度收录github博客]]></title>
    <url>%2Fp%2F5b944fdc.html</url>
    <content type="text"><![CDATA[今天给博客添加了 baidu 和 google 的校验文件，希望能让搜索引擎快速的收录博客的变更，但是操作中发现 baidu 的爬虫没办法爬去博客的 sitemap于是搜了下这个问题，发现有人向 github 提出了这个问题，github 的回答是将百度的爬虫给屏蔽了。。。那对于这样的问题我就很无奈了，有人说用 cdn，有人说用对百度爬虫另开一台服务器，专门给它爬。(前提是你的博客是绑定了自己域名的)我就想能不能综合下这两个想法呢?本身 github 的博客部署的是静态文件，那静态文件部署在另一个地方应当也可以，就像大家说的给百度爬虫另开一台服务器，但我并不想自己搭建服务器给博客，感觉还是有点负担。看到人家说不要用 github，转用 gitcafe，我想那我能不能部署两个 pages 呢，我习惯用 github，同时也部署在另一个百度爬虫可以访问的 pages 服务，这样我一旦部署完成，整个网站都不用我管理什么了。我以前用过 oschina 的码云，搜了下，现在码云也支持 pages 了，但是经过一番测试后发现可以搭建博客但是不支持自定义域名，在一番寻找之后选择了 gitlab。gitlab pages 使用gitlab 账户注册gitlab可以使用 github 账户直接登录，重新校验一下邮箱并设置下密码即可创建 yourname.gitlab.io 项目添加两个文件 index.html 和.gitlab-ci.yml内容如下:1234567891011121314151617$ cat index.htmlhello world!$ cat .gitlab-ci.ymlpages: stage: deploy script: - mkdir .public - cp -r * .public - mv .public public artifacts: paths: - public only: - master完成修改后 push 到 gitlab 上，这时会触发 gitlab 的 ci最后访问http://yourname.gitlab.io这时 gitlab 的 pages 服务就配置完成了，以后在博客变动后向对 github 提交一样，使用 git 向 gitlab 提交你的修改就行自定义域名可能我们有自己的域名想绑定到 gitlab pages，这时可以在项目的 pages 选项里进行添加，选择 settings-pages-new domain，输入你自己的域名(https 请提供相关文件)，然后就能看到提示你可以使用该域名访问了。给百度爬虫专用 dns我的域名是使用阿里云的域名解析，在这里我需要在原本 github.io 的解析之外添加一条百度专线的 cname如果你觉得 gitlab 的解析更方便，你可以将 gitlab 的解析线路改为默认，github 的解析线路改成海外。自动化 gitlab page 的部署虽然上面的方法解决了百度爬虫爬取的问题，但是我还是觉得比较麻烦，每次都要单独向 gitlab 推送下更新，我能不能将这一操作自动化呢?我在之前就使用 travis-ci 来自动化部署我 github 上提交的 hexo 代码，自动生成站点静态文件并提交到 github 的 master 分支上。自动化部署 github pages 博客请参见使用 Travis CI 自动更新 GitHub Pages使用 Travis CI 自动更新 Hexo Blog现在我希望的是在 travis-ci 里添加向 gitlab 自动 push 的代码。申请 gitlab 的 access token在 gitlab 的个人设置页面找到 access token 并如下填写各项内容，然后会生成一个 token 字符串，复制它备用。将 gitlab 的 access token 加入 travis-ci 的环境变量登陆travis-ci.org并在项目设置中添加 gitlab token 的环境变量取消 gitlab 的 master 分支 force push 保护由于我们要在 ci 中强制把生成的站点文件 push 到 gitlab，需要将 gitlab 对应的 master 分支解除保护选择项目的 settings-repository 下的 protected branchs 将 master 从中删除添加.gitlab-ci.yml 并修改.travis-ci.yml 文件将之前在 gitlab 中使用的.gitlab-ci.yml 添加至 git 仓库修改.travis-ci.yml 文件，增加 gitlab 分支的 push 部分(after_script 的最后两行 以及 env 下的 GL_REF 变量)12345678910111213141516171819202122232425262728293031language: node_jsnode_js: lts/*# S: Build Lifecycleinstall: - npm installscript: - cp material_theme_config.yml themes/hexo-theme-material/_config.yml - hexo gafter_script: - cd ./public - git init - git config user.name "terryding77" - git config user.email "terryding77@gmail.com" - git add . - git commit -m "Update docs" - git push --force --quiet "https://$&#123;GITHUB_TOKEN&#125;@$&#123;GH_REF&#125;" master:master - cp ../.gitlab-ci.yml ./ &amp;&amp; git add .gitlab-ci.yml &amp;&amp; git commit -m "add ci file" - git push --force --quiet "https://oauth2:$&#123;GITLAB_TOKEN&#125;@$&#123;GL_REF&#125;" master:master# E: Build LifeCyclebranches: only: - blog-sourceenv: global: - GH_REF: github.com/terryding77/terryding77.github.io.git - GL_REF: gitlab.com/terryding77/terryding77.gitlab.io.git在完成修改后将代码 push 到 github 上，然后就等待 travis-ci 和 gitlab-ci 完成部署即可~]]></content>
      <categories>
        <category>SEO</category>
      </categories>
      <tags>
        <tag>seo</tag>
        <tag>baidu</tag>
        <tag>gitlab</tag>
        <tag>dns</tag>
        <tag>travis-ci</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle数据库Sql的With As语句]]></title>
    <url>%2Fp%2F53462dca.html</url>
    <content type="text"><![CDATA[问题描述今天碰到一道 sql 的题目，问题简化下来就是一张存有 id 和订单号的表格 orders，筛选出拥有最多订单的所有 id。样例idorderNumber1000110003200063000830010这张表经过查询语句应当返回：id13原因是 id 为 1 和 3 的用户都拥有 2 条订单，同时 2 条订单是最多的单个用户所拥有的订单数量。解决方法对于这题主要的就是要能获得一张 id 对应 id 拥有订单总数的表格，然后再对这张表格做处理。这样的思路在 mysql 下我的写法是这样的12345678select t1.idfrom (select id, count(orderNumber) as counts from orders group by id) as t1, (select count(orderNumber) as max_counts from orders group by id order by count(orderNumber) desc limit 1) as t2where t1.counts = t2.max_counts;其中 t1 表完成 id 对应拥有订单总数的表格，t2 是 t1 中最大的订单数量，但写法上可以发现 t1 和 t2 的构造有很大一部分是冗余的，但我一时也无法找到合适的写法去除这个冗余。在查找解决方法的时候我尝试着对应我在 python 中使用的 with as 写法来搜索，发现 sql 中也有这种写法，可是在 mysql 中尝试不得成功。看大家说 Oracle 可以，我就想着在 Oracle 中试试。Oracle 数据库安装简单的搜索了 Oracle 数据的的安装教程，感觉好像很麻烦，而我又是只想简单使用，想着应该可以用 docker 来安装。看到了排名第一的 Oracle 镜像，转战 github 查看下源码仓库，其中包含了 dockerfile 和使用指南等，对我来说，如何运行 docker 镜像以及登录 Oracle 命令行是我想知道的，稍微阅读下使用指南，知道了镜像对应的端口以及 Oracle 数据库的默认用户名密码，开始运行镜像并登录：Oracle 数据库 with as 写法with as 的写法大致为with 别名 as (表的定义)这样的形式，其中表的定义可以使用 select 语句或者其他能产生表的方法。对于上述题目，我使用 with as 的写法如下：12345with t1 as (select id, count(orderNumber) as counts from orders group by id), t2 as (select max(counts) as max_counts from t1)select t1.id from t1, t2 where t1.counts = t2.max_counts;with as 的写法可以并列多条，后面的可以使用前面已经定义好的表，如 t2 的定义就使用了 t1 表。有了这样的语法，在书写一些重复运算比较多的 sql 时就可以将其使用 with as 优先定义，就有点像使用函数的感觉。这在提高效率的同时，可读性也提高不少。ps: 测试数据导入1234567891011121314151617181920212223242526# mysql database test env settings# choose database first by "use your-test-database-name;"create table orders(id int, orderNumber VARCHAR(10));insert into orders values (1, "0001"), (1, "0003"), (2, "0006"), (3, "0001"), (3, "0010");select * from orders;# Oracle database test env settingscreate table orders(id int, orderNumber VARCHAR(10));insert all into orders values (1, '0001') into orders values (1, '0003') into orders values (2, '0006') into orders values (3, '0001') into orders values (3, '0010')select 1 from dual;select * from orders;# normal env settings;create table orders(id int, orderNumber VARCHAR(10));insert into orders values (1, '0001');insert into orders values (1, '0003');insert into orders values (2, '0006');insert into orders values (3, '0001');insert into orders values (3, '0010');select * from orders;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
        <tag>sql</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu 17.04下安装docker国内镜像教程]]></title>
    <url>%2Fp%2F1a833b74.html</url>
    <content type="text"><![CDATA[前几天看到新闻说 ubuntu 以后要回归默认 gnome，于是就在虚拟机下安装了新版的 ubuntu-gnome17.04。顺手就总结下在纯净的 ubuntu 下安装 docker 的过程。apt 源安装 docker自从 ubuntu 不知道哪个版本开始，就在 apt 源里自带 docker 了，不过不叫 docker，名字叫 docker.io。（注意：docker 这个名字也对应着一个包，但不是我们要装的东西~）所以如果想要默认安装，请直接运行sudo apt-get install docker.io -y 就可以了。配置国内加速镜像docker 安装完成后，我们关键的还是需要配置一个国内的镜像源，不然每次拉取(pull)镜像的过程是相当漫长的。对此我们可以选择 aliyun 或者 daocloud 等国内公司。这里以 aliyun 为例子：你需要在 aliyun 上注册一个账号，然后访问https://cr.console.aliyun.com/#/accelerator地址，上面会有你的加速地址，以替换下述命令中的网址。123456789# setting aliyun sourcesudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'&#123; "registry-mirrors": ["https://your.mirror.aliyuncs.com"]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker测试 docker 命令我们可以使用sudo docker run hello-world来测试下 docker 的安装情况，若一切正常，会显示这时 docker 的安装就完成了，但如果你是一个像我一样的懒虫，这些可能还不够， 你发现在使用 docker 的时候需要不断的输入 sudo，并提供密码之类的， 那是否有办法可以不输入 sudo，以当前用户来完成 docker 的操作呢?答案是肯定的~免 sudo 运行 docker 命令经过一番搜索，我们发现了其实运行 docker 指令就是和 docker 的进程进行通信， 而通信过程中使用的是 socket 文件，查看该 socket 文件，我们发现该 socket 文件的权限有点特别:它是属于root 用户和docker 组的，这个 docker 组是什么呢?查找了下文档，我们发现docker 官方文档里就有这样一段话，并解决了我们的问题：The docker daemon binds to a Unix socket instead of a TCP port. By default that Unix socket is owned by the user root and other users can only access it using sudo. The docker daemon always runs as the root user.If you don’t want to use sudo when you use the docker command, create a Unix group called docker and add users to it. When the docker daemon starts, it makes the ownership of the Unix socket read/writable by the docker group.因此，参照文档中的做法，运行如下命令：1234sudo groupadd dockersudo usermode -aG docker $USERsudo groups $USER # check which groups I joined.## username : group1 group2 .... docker # expected output然后注销用户，再次登录后即可（我是直接重启~ 虚拟机丢那自己动图方便）至此，我们就完成了 docker 在 ubuntu-gnome17.04 上的安装。]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则匹配一个数字(python实现)]]></title>
    <url>%2Fp%2F2ee1faa1.html</url>
    <content type="text"><![CDATA[问题描述给定一组字符串，判断该字符串是否为一个合法的数字，要求如下基本整数数字是 0-9 的组合整数不可有前导 0 (如: 012 就不合法)小数包含(x.y, .y, x.)三种形式，此时 x 和 y 符合第 1 条且可以有前导 0无论整数或小数都可以选择在最前方加入+-之一或者不加，以表达该数字的正负数字支持”x^y”的形式以表达 x 的 y 次方的意义，^不能作为一个数字的开头或结尾，同时 x 和 y 均为符合前 4 条条件的数字数字支持”xey”的形式以表达 x 乘以 10 的 y 次方的意义，e 不能作为一个数字的开头或结尾，同时 x 符合前 4 条条件，y 符合条件 1 和 4(即：允许前导 0 的整数)测试样例“+1.23” is True“-1.23” is True“1.23” is True“.23” is True“1.” is True“0.” is True“+123” is True“-123” is True“123” is True-“1.23e+123” is True“1.23e-123” is True“1.23e123” is True“1.23e0123” is True-“1.23^+123” is True“1.23^-123” is True“1.23^123” is True-“1.23^+1.23” is True“1.23^-1.23” is True“1.23^1.23” is True“1.23^.23” is True“1.^1.” is True“1.^0.” is True-“” is False“a.” is False“.” is False-“-1.2.3” is False“-1.-2” is False“0123” is False-“1.23e1.2” is False“1.23e” is False“1.23e1e2” is False“1.23e1^2” is False-“1.23^1.2.3” is False“1.23^” is False“1.23^0123” is False“1.23^1^2” is False“1.23^1e2” is False思路最开始的思路是先确定数字中是否包含 e 或者^符号，如果有，用其将数字切开，分别对前后进行判断，后来整理清楚要求后，发现可以用正则来进行匹配，正则的整体方案也基本等价于一开始的思路对于小数使用\d*.\d+ 来匹配 x.y .y 的形式， \d+. 来匹配 x.的形式对于整数使用[1-9]\d*来匹配无前导 0 的形式，\d+ 来匹配有前导 0 的形式对以上的几种形式再与- + e ^ 等符号进行按要求的连接即可形成完整的正则代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import redef numberCheck(numberStr): numberRegex = re.compile("[-+]?(" "(\d*\.\d+)|" # match x.y .y format "(\d+\.)|" # match x. format "([1-9]\d*)" # match Integer format(without lead zero) ")" # a simple number (both Integer and Double) "(" "(e[+-]?\d+)" # if "e" in number, we need a Integer(can lead with zero) below "|" "(\^[+-]?((\d*\.\d+)|(\d+\.)|([1-9]\d*)))" # if "^" in number, we need a simple number below ")?" ) return numberRegex.fullmatch(numberStr) is not Nonedef testNumberCheck(): assert numberCheck("+1.23") is True assert numberCheck("-1.23") is True assert numberCheck("1.23") is True assert numberCheck(".23") is True assert numberCheck("1.") is True assert numberCheck("0.") is True assert numberCheck("+123") is True assert numberCheck("-123") is True assert numberCheck("123") is True assert numberCheck("1.23e+123") is True assert numberCheck("1.23e-123") is True assert numberCheck("1.23e123") is True assert numberCheck("1.23e0123") is True assert numberCheck("1.23^+123") is True assert numberCheck("1.23^-123") is True assert numberCheck("1.23^123") is True assert numberCheck("1.23^+1.23") is True assert numberCheck("1.23^-1.23") is True assert numberCheck("1.23^1.23") is True assert numberCheck("1.23^.23") is True assert numberCheck("1.^1.") is True assert numberCheck("1.^0.") is True assert numberCheck("") is False assert numberCheck("a.") is False assert numberCheck(".") is False assert numberCheck("-1.2.3") is False assert numberCheck("-1.-2") is False assert numberCheck("0123") is False assert numberCheck("1.23e1.2") is False assert numberCheck("1.23e") is False assert numberCheck("1.23e1e2") is False assert numberCheck("1.23e1^2") is False assert numberCheck("1.23^1.2.3") is False assert numberCheck("1.23^") is False assert numberCheck("1.23^0123") is False assert numberCheck("1.23^1^2") is False assert numberCheck("1.23^1e2") is Falseif __name__ == '__main__': testNumberCheck()]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数快速幂(c++实现)]]></title>
    <url>%2Fp%2F5121bb7.html</url>
    <content type="text"><![CDATA[问题描述给定两个 int 范围的整数 m 和 n(m&lt;10^9, n&lt;10^5)，求出 m 的 n 次方的值，并使用 string 类型返回该数字。思路由 m 和 n 的范围可以看出，m 的 n 次方可能是个很大的数字:m 可以取到约 10 的 9 次方，所以 m 的 n 次方最大可以约 10 的 9n 次方，使用 10 进制表示可以是 1 后面跟上 9n 个 0，如果方法不合适，可能根本无法计算，对此，我们需要使用快速幂的思想来帮助简化 n 次方运算, 同时对超越 int 大小范围的乘法运算，使用 vector 容器来保持数字的值，由于 int 范围略大于 10^9, 我们在 vector 中每个元素存储 10^4 大小的数字，这样保证在乘法运算时也不至于超过 int 大小。代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;bits/stdc++.h&gt;using namespace std;class BigInteger &#123; vector&lt;unsigned int&gt; numberArray; bool isNegative; static const unsigned int MOD = 10000;public: BigInteger(int n) &#123; isNegative = n &lt; 0; unsigned int un = abs(n); numberArray.clear(); if(un == 0) &#123; numberArray.push_back(0); &#125; else &#123; while(un) &#123; numberArray.push_back(un % MOD); un /= MOD; &#125; &#125; &#125; BigInteger(const BigInteger &amp; original) &#123; numberArray.reserve(original.numberArray.size()); copy(original.numberArray.begin(), original.numberArray.end(), back_inserter(numberArray)); isNegative = original.isNegative; &#125; string toString() &#123; string ret = isNegative ? "-" : ""; for(auto it = numberArray.crbegin(); it != numberArray.crend(); it ++) &#123; ret += to_string(*it); &#125; return ret; &#125; BigInteger pow(int n) &#123; BigInteger ret(1), mul(*this); while(n) &#123; if(n &amp; 1) &#123; ret *= mul; &#125; n &gt;&gt;= 1; mul *= mul; &#125; return ret; &#125; void format() &#123; unsigned int more = 0; for(int i = 0; i &lt; numberArray.size(); i ++) &#123; unsigned int tmp = numberArray[i] + more; more = tmp / MOD; numberArray[i] = tmp % MOD; &#125; while(more) &#123; numberArray.push_back(more % MOD); more /= MOD; &#125; while(numberArray.size() &gt; 1 &amp;&amp; numberArray[numberArray.size() - 1] == 0) &#123; numberArray.pop_back(); &#125; &#125; BigInteger&amp; operator *=(const BigInteger&amp; mul) &#123; return *this = (*this) * mul; &#125; BigInteger operator *(const BigInteger&amp; b) &#123; BigInteger ret(0); ret.numberArray.resize(numberArray.size() + b.numberArray.size(), 0); for(int i = 0; i &lt; numberArray.size(); i ++) &#123; for(int j = 0; j &lt; b.numberArray.size(); j ++) &#123; ret.numberArray[i + j] += numberArray[i] * b.numberArray[j]; &#125; &#125; ret.format(); ret.isNegative = isNegative ^ b.isNegative; return ret; &#125;&#125;;int main() &#123; int m, n; while(cin&gt;&gt;m&gt;&gt;n) &#123; if(n == 0 &amp;&amp; m == 0) break; BigInteger bigM(m); BigInteger result = bigM.pow(n); cout&lt;&lt; result.toString()&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>大数运算</tag>
        <tag>快速幂</tag>
      </tags>
  </entry>
</search>
